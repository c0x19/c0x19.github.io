---
title: gdb查看内存
date: 2019-04-23 14:26:26
tags:
---

# 数据在内存中存储形式 #

不论什么类型的数据，在机器中都是以0或者1，即bit来存储的，而有了内存后，最小的存储数据单元是字节，1byte=2hex=8bit

## 存储类型 ##

不论什么类型，在内存中实际都是16进制存储的数据，根据类型的不同显示出不同的结果，来给人看。**所有数据都是16进制，不同的是字节长度**

类型转换

- 低到高直接自动转换，高类型的高位自动填充0即可
- 低到高需要截断，根据类型的长度来从低位开始截断，即强制类型转换


## 存储顺序 ##

在内存中，**数据都是按内存地址顺序从低到高存储的**

> 字节顺序是指占内存多于一个字节类型的数据在内存中的存放顺序——百度百科

为什么会产生存储顺序问题，之前一直没搞懂，今天有了一点想法，似乎因为对内存的访问是通过地址来实现的，比如访问一个int类型，有4个字节，我们访问的是int类型的首字节地址，在int这个四字节“unit”中，实际数值在每个字节中如何放置，这里就产生了数据问题，即小端法还是大端法

比如一个int类型变量，有4个字节长度，数值为0x12345678，分配给变量的内存地址为0x01 0x02 0x03 0x04

（我们访问变量，其实就是访问0x01，然后根据变量的类型，给我们连续4个字节的值）

小端法：数值低字节放在内存地址低字节
大端法：数值高字节放在内存地址低字节

|内存地址|0x01|0x02|0x03|0x04|
|---    |---:|---:|---:|:--:|
|小端法  |0x78|0x56|0x34|0x12|
|大端法  |0x12|0x34|0x56|0x78|


# 查看内存 #


gdb中用X指令来查看内存

`x/[n/f/u] addr`

n、f、u是可选参数，addr是要查看的内存地址

- n：显示几个units
- f：格式，具体可选：
	- x：按16进制格式显示，是默认值
	- d：按10进制显示
	- u：按无符号10进制显示
	- o：按8进制显示
	- t：按二进制显示
	- i：指令显示
	- s：字符串显示
	- a：16进制格式显示地址
	- c：按字符串显示
	- f：按浮点数显示
- u：显示unit的大小，即将内存按unit块一个一个显示，unit块中用了小端法
	- b：单字节
	- h：双字节
	- w：四字节
	- g：八字节



addr是内存地址，可以用直接地址，如0x8048000，或者用寄存器，如$esp,$esp+0x10

常用命令：x/30xw $rsp
	


